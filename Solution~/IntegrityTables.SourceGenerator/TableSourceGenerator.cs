using System.Linq;
using System.Text;
using IntegrityTables.SourceGeneration.Model;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace IntegrityTables.SourceGeneration;

public class TableSourceGenerator 
{
    public static void GenerateCode(SourceProductionContext context, DatabaseModel model)
    {
        foreach (var table in model.Tables)
        {
            var referenceFields = new StringBuilder();
            var getterCode = new StringBuilder();
            var setterCode = new StringBuilder();
            var flattenRowExtensions = new StringBuilder();
            
            for (var i = 0; i < table.Fields.Count; i++)
            {
                var field = table.Fields[i];
                var fieldType = field.TypeName;
                var fieldName = field.Name;
                flattenRowExtensions.AppendLine($"        public static {fieldType} {fieldName} (this Row<{table.TypeName}> row) => row.data.{fieldName};");
                if(field.IsImmutable)
                    flattenRowExtensions.AppendLine($"        public static void {fieldName} (ref this Row<{table.TypeName}> row, {fieldType} value) => throw new InvalidOperationException(\"This field is marked [Immutable]\");");
                else if(field.IsComputed)
                    flattenRowExtensions.AppendLine($"        public static void {fieldName} (ref this Row<{table.TypeName}> row, {fieldType} value) => throw new InvalidOperationException(\"This field is marked [Computed]\");");
                else
                    flattenRowExtensions.AppendLine($"        public static void {fieldName} (ref this Row<{table.TypeName}> row, {fieldType} value) => row.data.{fieldName} = value;");
                // if field is an object, just print "Object" else get the value.
                getterCode.Append($"                case {i+1}: return row.data.{fieldName};\n");
                setterCode.Append($"                case {i+1}: row.data.{fieldName} = ({fieldType})value; break;\n");
                if (!field.IsReference) continue;
                if (field.PropertyName != null) referenceFields.AppendLine($"        public Row<{field.ReferencedTableModel.TypeName}>? {field.PropertyName} {{ get; set; }}");
            }

            var referencingTypes = "";
            if(table.Dependencies.Count > 0)
                referencingTypes = string.Join(", ", table.Dependencies.Select(i => $"(typeof({i.TableModel.TypeName}), \"{i.Name}\")"));
            
            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/> // {DatabaseSourceGenerator.GenerationStamp()}

using System;
using System.Collections.Generic;
using IntegrityTables;
");
            if (!string.IsNullOrEmpty(table.NameSpace))
            {
                sb.AppendLine($"namespace {table.NameSpace}");
                sb.AppendLine("{");
            }

            var fieldTypes = string.Join(", ", table.Fields.Select(f => $"typeof({f.QualifiedTypeName})"));
            var fieldNames = string.Join(", ", table.Fields.Select(f => $"nameof({table.FullyQualifiedTypeName}.{f.Name})"));
            var referencedTypes = string.Join(", ", table.Fields.Select(field => field.IsReference ? $"typeof({field.ReferencedTableModel.TypeName})" : $"null").ToList());
            sb.AppendLine($@"
    // {DatabaseSourceGenerator.GenerationStamp()}
    public partial class {table.TypeName}Metadata : ITableMetadata<Row<{table.TypeName}>>
    {{
        public string Group => ""{table.GroupName}"";

        public string[] Names => new string[] {{ ""id"", {fieldNames} }};

        public Type[] Types => new Type[] {{ typeof(int), {fieldTypes} }};

        public Type[] ReferencedTypes => new Type[] {{ null, {referencedTypes} }};

        public (Type type, string fieldName)[] ReferencingTypes => new (Type type, string fieldName)[] {{ {referencingTypes} }};

        public int Count => Names.Length;

        public bool IsBlittable => {table.IsBlittable.ToString().ToLowerInvariant()};

        public bool IsComponent => {table.IsComponent.ToString().ToLowerInvariant()};

        // {DatabaseSourceGenerator.GenerationStamp()}
        public object Get(in Row<{table.TypeName}> row, int index)
        {{
            switch(index) {{
                case 0: return row.id;
{getterCode}
                default: throw new ArgumentOutOfRangeException(nameof(index));
            }}
        }}

        // {DatabaseSourceGenerator.GenerationStamp()}
        public void Set(ref Row<{table.TypeName}> row, int index, object value)
        {{
            switch(index) {{
                case 0: row.id = (int)value; break;
{setterCode}
                default: throw new ArgumentOutOfRangeException(nameof(index));
            }}
        }}

        // {DatabaseSourceGenerator.GenerationStamp()}
        public int IndexOf(string name)
        {{
            for (var i = 0; i < Names.Length; i++)
                if (Names[i] == name) return i;
            return -1;
        }}

        // {DatabaseSourceGenerator.GenerationStamp()}
        public (int index, string name, Type type, Type referencedType) GetInfo(int index)
        {{
            if (index < 0 || index >= Names.Length)
                throw new ArgumentOutOfRangeException(nameof(index));

            return (index, Names[index], Types[index], ReferencedTypes[index]);
        }}

        string[] ITableMetadata.Names => Names;
        Type[] ITableMetadata.Types => Types;
        Type[] ITableMetadata.ReferencedTypes => Types;
        int ITableMetadata.Count => Count; 

        object ITableMetadata.Get(object d, int i) => Get((Row<{table.TypeName}>)d, i);

        // {DatabaseSourceGenerator.GenerationStamp()}
        void ITableMetadata.Set(ref object d, int i, object v)
        {{
            var dd = (Row<{table.TypeName}>)d;
            Set(ref dd, i, v);
            d = dd;
        }}

        (int index, string name, Type type, Type referencedType) ITableMetadata.GetInfo(int index) => GetInfo(index);

        int ITableMetadata.IndexOf(string n) => IndexOf(n);
    }}

    // {DatabaseSourceGenerator.GenerationStamp()}
    public partial struct {table.TypeName} : IEquatable<{table.TypeName}> {{
{GeneratePartialComputeMethods(table)}     
        // {DatabaseSourceGenerator.GenerationStamp()}   
        public bool Equals({table.TypeName} other)
        {{
{GenerateEquals(table)}            
        }}

        // {DatabaseSourceGenerator.GenerationStamp()}
        public override bool Equals(object obj)
        {{
            return obj is {table.TypeName} other && Equals(other);
        }}

        // {DatabaseSourceGenerator.GenerationStamp()}
        public override int GetHashCode()
        {{
{GenerateHashCode(table)}            
        }}

        // {DatabaseSourceGenerator.GenerationStamp()}
        public static bool operator ==({table.TypeName} left, {table.TypeName} right)
        {{
            return left.Equals(right);
        }}

        // {DatabaseSourceGenerator.GenerationStamp()}
        public static bool operator !=({table.TypeName} left, {table.TypeName} right)
        {{
            return !left.Equals(right);
        }}
    }}
    
    // {DatabaseSourceGenerator.GenerationStamp()}
    public static class Row{table.TypeName}Extensions {{
{flattenRowExtensions}

        // {DatabaseSourceGenerator.GenerationStamp()}
        /// <summary>
        /// Save the current row to the database. The same as `db.{table.FacadeName}.Update(ref row)`.
        /// </summary>
        public static void Save(ref this Row<{table.TypeName}> row)
        {{
            var db = Context<{model.DatabaseSymbol.Name}>.Current;
            db.{table.FacadeName}.Update(ref row);     
        }}

        // {DatabaseSourceGenerator.GenerationStamp()}
        /// <summary>
        /// Refresh row with latest data from the database. The same as `row = db.{table.FacadeName}.Get(row.id)`.
        /// </summary>
        public static void Refresh(ref this Row<{table.TypeName}> row)
        {{
            var db = Context<{model.DatabaseSymbol.Name}>.Current;
            row = db.{table.FacadeName}.Get(row.id);     
        }}
    }}

    // {DatabaseSourceGenerator.GenerationStamp()}
    public static class Table{table.TypeName}Extensions {{
{BuildUniqueLookupMethods(context, table)}

{BuildEnumLookupMethods(context, table)}

        // {DatabaseSourceGenerator.GenerationStamp()}
        public static IEnumerable<{table.TypeName}> GetDefaultData(this Table<{table.TypeName}> table) {{
{GenerateDefaultData(table)}
            yield break;
        }} 

        public static bool IsBlittable(this Table<{table.TypeName}> table) => {(table.IsBlittable?"true":"false")};

    }}
");
            if (!string.IsNullOrEmpty(table.NameSpace)) sb.AppendLine("}");
            context.AddSource($"{model.FileName("Table", table.TypeName)}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    private static string GenerateHashCode(TableModel table)
    {
        var sb = new StringBuilder();
        sb.AppendLine("            var hash = new System.HashCode();");
        for (var index = 0; index < table.Fields.Count; index++)
        {
            var field = table.Fields[index];
            if (field.IgnoreForEquality) continue;
            sb.AppendLine($"            hash.Add({field.Name});");
        }
        sb.AppendLine("            return hash.ToHashCode();");
        return sb.ToString();
    }

    private static string GenerateEquals(TableModel table)
    {
        var sb = new StringBuilder();
        sb.Append("            return (");
        for (var index = 0; index < table.Fields.Count; index++)
        {
            var field = table.Fields[index];
            if (field.IgnoreForEquality) continue;
            sb.Append($"{field.Name} == other.{field.Name}");
            sb.Append(" && ");
        }
        sb.Append("true);");
        return sb.ToString();
    }

    private static string GeneratePartialComputeMethods(TableModel table)
    {
        var sb = new StringBuilder();
        foreach (var field in table.Fields)
        {
            if (field.IsComputed)
            {
                sb.AppendLine($"        public static partial {field.TypeName} Compute_{field.Name}({table.DatabaseModel.TypeName} db, Row<{table.QualifiedTypeName}> row);");
            }
        }
        return sb.ToString();
    }

    private static string GenerateDefaultData(TableModel tableModel)
    {
        var sb = new StringBuilder();
        foreach (var defaultData in tableModel.DefaultDataMethods)
        {
            sb.AppendLine($"            foreach(var row in {tableModel.TypeName}.{defaultData}()) yield return row;");
        }

        return sb.ToString();
    }

    private static string BuildEnumLookupMethods(SourceProductionContext context, TableModel table)
    {
        if (table.GenerateEnum == null) return "";
        return ($@"
        // {DatabaseSourceGenerator.GenerationStamp()}
        /// <summary>
        /// Lookup a single {table.TypeName} row by its enum id.
        /// </summary>
        public static Row<{table.QualifiedTypeName}> GetBy(this Table<{table.QualifiedTypeName}> table, {table.GenerateEnum.Name} value) {{
            return table.Get((int)value);
        }}");
    }

    private static string BuildUniqueLookupMethods(SourceProductionContext context, TableModel table)
    {
        var sb = new StringBuilder();
        foreach (var kv in table.UniqueIndexes)
        {
            var fields = kv.Value;
            // only handle single-column uniques here
            if (fields.Count == 1)
            {
                var f    = fields[0];
                if(f.IsReference) // don't generate methods for reference fields, as they are handled by TableIndex classes.
                    continue;
                var name = f.FieldSymbol.Name;                        // e.g. "Email"
                var type = f.FieldSymbol.Type.ToDisplayString();      // e.g. "string"
                var cap  = char.ToUpperInvariant(name[0]) + name.Substring(1);

                var tableQualifiedTypeName = table.TypeName;
                sb.AppendLine($@"
        // {DatabaseSourceGenerator.GenerationStamp()}
        /// <summary>
        /// Lookup a single {table.TypeName} row by its uniquely-indexed `{name}`.
        /// </summary>
        public static Row<{tableQualifiedTypeName}> GetBy{cap}(this Table<{tableQualifiedTypeName}> table, {type} value) {{
            return table.GetByUniqueIndex(""{kv.Key}"", value);
        }}");
                

                sb.AppendLine($@"
        /// <summary>
        /// Try to lookup a single {table.TypeName} row by `{name}`.
        /// </summary>
        public static bool TryGetBy{cap}(this Table<{tableQualifiedTypeName}> table, {type} value, out Row<{table.QualifiedTypeName}> row)
        {{
            return table.TryGetByUniqueIndex(""{kv.Key}"", value, out row);
        }}");
            }
            
        }
        return sb.ToString();
    }
}