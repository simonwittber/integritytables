using System.Collections.Generic;
using System.Linq;
using System.Text;
using IntegrityTables.SourceGeneration.Model;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace IntegrityTables.SourceGeneration;

public class ViewModelSourceGenerator
{
    public static void GenerateCode(SourceProductionContext context, DatabaseModel model)
    {
        ViewModelManagerSourceGenerator.GenerateViewModelManager(context, model);
        foreach (var tableModel in model.Tables)
        {
            if (!tableModel.GenerateViewModel) continue;

            var manyToManyDependencies = tableModel.Dependencies
                .Where(i => i.TableModel.IsManyToMany && i.TableModel.GenerateViewModel && !string.IsNullOrEmpty(i.CollectionName))
                .ToList();
                
            
            var sb = new StringBuilder();
            sb.AppendLine($@"// <auto-generated/> // {DatabaseSourceGenerator.GenerationStamp()}
using System;
using System.Collections.Generic;

using IntegrityTables;
");
            if (!string.IsNullOrEmpty(tableModel.NameSpace))
            {
                sb.AppendLine($"namespace {tableModel.NameSpace}");
                sb.AppendLine("{");
            }

            sb.AppendLine($@"

// {DatabaseSourceGenerator.GenerationStamp()}
public class {tableModel.TypeName}ViewModelCollection : IDisposable
{{
    private readonly Dictionary<int, {tableModel.TypeName}ViewModel> cache = new();
    private readonly {model.TypeName}ViewModelManager manager;

    public int Count => cache.Count;

    public {tableModel.TypeName}ViewModelCollection({model.TypeName}ViewModelManager manager)
    {{
        this.manager = manager;
    }}

    public {tableModel.TypeName}ViewModel Get(int id)
    {{
        if (!cache.TryGetValue(id, out var viewModel))
        {{
            cache[id] = viewModel = new {tableModel.TypeName}ViewModel(manager, id);
            viewModel.Init();
        }}
        return viewModel;
    }}

    public void Remove(int id)
    {{
        if (cache.TryGetValue(id, out var viewModel))
        {{
            viewModel.Dispose();
            cache.Remove(id);
        }}
    }}

    public void Dispose() 
    {{
        foreach (var viewModel in cache.Values)
        {{
            viewModel.Dispose();
        }}
        cache.Clear();
    }}
}}

// {DatabaseSourceGenerator.GenerationStamp()}
public partial class {tableModel.TypeName}ViewModel : IViewModel, IDisposable
{{
    
    public readonly int id;
    private IDisposable observer;
    private Row<{tableModel.TypeName}> row;

    private {model.TypeName}ViewModelManager manager;
    protected {model.TypeName} db => manager.db;

{GenerateProperties(tableModel)}

{GenerateDependencyProperties(tableModel)}
{GenerateManyToManyProperties(tableModel, manyToManyDependencies)}

    public {tableModel.TypeName}ViewModel({model.QualifiedTypeName}ViewModelManager manager, int id)
    {{
        this.manager = manager;
        this.id = id;
    }}

    // {DatabaseSourceGenerator.GenerationStamp()}
    // A separate Init method is used so that the ViewModel collection can can be created without causing an infinite loop,
    // since the ViewModelManager will try to get the ViewModels for it's dependencies when it is created, which may
    // circle back and create a new ViewModel for this table...
    public void Init() 
    {{
        this.row = db.{tableModel.FacadeName}.Get(id);
        observer = db.{tableModel.FacadeName}.AddObserver(row, OnRowUpdated);
        using var scope = manager.db.CreateContext();
{GenerateDependencyObservers(tableModel)}
{GenerateManyToManyObservers(tableModel, manyToManyDependencies)}
        OnRowUpdated(row);
    }}

    // {DatabaseSourceGenerator.GenerationStamp()}
    void OnRowUpdated(Row<{tableModel.TypeName}> newRow)
    {{
        row = newRow;
{GenerateValueChanged(tableModel)}
    }}
    
    // {DatabaseSourceGenerator.GenerationStamp()}
    public void Dispose() 
    {{
        observer.Dispose();
{GenerateDependencyDisposers(tableModel)}
{GenerateManyToManyDisposers(tableModel, manyToManyDependencies)}
        observer = null;
        manager = null;
        row = default;
    }}
}}
");
            if (!string.IsNullOrEmpty(tableModel.NameSpace))
            {
                sb.AppendLine("}//x");
            }

            context.AddSource($"{model.FileName("ViewModel", tableModel.TypeName)}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    
    private static string GenerateManyToManyObservers(TableModel tableModel, List<FieldModel> manyToManyDependencies)
    {
        var sb = new StringBuilder();
        sb.AppendLine("        // Many-to-many relationships");
        foreach (var i in manyToManyDependencies)
        {
            // i.TableModel is the many-to-many table, so we need to get the actual table model from the ManyToManyModel
            var manyToMany = tableModel.DatabaseModel.ManyToManyModels.First(q => q.TableModel == i.TableModel);
            
            var otherField = manyToMany.Fields.First(q => q != i);
            var viewCollection = $"{i.CollectionName}";
            var idList = $"{i.TableModel.TypeName}_{i.CapitalizedName}Ids";
            sb.AppendLine($"        // need to watch {manyToMany.Fields[0].Name} and {manyToMany.Fields[1].Name} for changes");
            sb.AppendLine($"        {idList} = db.{i.TableModel.FacadeName}.ObserveBy{i.CapitalizedName}(id);");
            sb.AppendLine(@$"        {i.TableModel.TypeName}_{i.CapitalizedName}ItemAdded = (index, id) => {{
            // get {i.TableModel.TypeName} row
            var junctionRow = db.{i.TableModel.FacadeName}.Get(id);
            // use {otherField.Name} to get the distant table model
            {i.CollectionName}Index[index] = {viewCollection}.Count;
            {viewCollection}.Add(manager.{otherField.ReferencedTableModel.TypeName}ViewModels.Get(junctionRow.data.{otherField.Name}));
        }};
        {idList}.ItemAdded += {i.TableModel.TypeName}_{i.CapitalizedName}ItemAdded;
        {i.TableModel.TypeName}_{i.CapitalizedName}ItemRemoved = (index, id) => {{
            var realIndex = {i.CollectionName}Index[index];
            {viewCollection}.RemoveAt(realIndex);
        }};
        {idList}.ItemRemoved += {i.TableModel.TypeName}_{i.CapitalizedName}ItemRemoved;
        for(var {i.TableModel.TypeName}_{i.CapitalizedName}=0; {i.TableModel.TypeName}_{i.CapitalizedName} < {idList}.Count; {i.TableModel.TypeName}_{i.CapitalizedName}++)
        {{
            var junctionRow = db.{i.TableModel.FacadeName}.Get({idList}[{i.TableModel.TypeName}_{i.CapitalizedName}]);
            // use {otherField.Name} to get the distant table model
            {i.CollectionName}Index[{i.TableModel.TypeName}_{i.CapitalizedName}] = {viewCollection}.Count;
            {viewCollection}.Add(manager.{otherField.ReferencedTableModel.TypeName}ViewModels.Get(junctionRow.data.{otherField.Name}));
        }}");
            
        }
        return sb.ToString();
    }


    private static string GenerateDependencyObservers(TableModel tableModel)
    {
        var sb = new StringBuilder();
        foreach (var i in tableModel.Dependencies)
        {
            var idCollection = $"{i.CollectionName}Ids";
            var viewCollection = $"{i.CollectionName}";
            if (!i.TableModel.GenerateViewModel) continue;
            if (string.IsNullOrEmpty(i.CollectionName)) continue;
            if (i.TableModel.IsManyToMany) continue;

            sb.AppendLine($@"        {idCollection} = db.{i.TableModel.FacadeName}.ObserveBy{i.CapitalizedName}(id);
        {i.CollectionName}ItemAdded = (index, id) => {viewCollection}.Add(manager.{i.TableModel.TypeName}ViewModels.Get(id)); 
        {idCollection}.ItemAdded += {i.CollectionName}ItemAdded;
        {i.CollectionName}ItemRemoved = (index, id) => {viewCollection}.RemoveAt(index);
        {idCollection}.ItemRemoved += {i.CollectionName}ItemRemoved;
        foreach(var {i.Name} in {idCollection})
        {{
            {viewCollection}.Add(manager.{i.TableModel.TypeName}ViewModels.Get({i.Name}));
        }}
");
        }

        return sb.ToString();
    }
    private static string GenerateManyToManyDisposers(TableModel tableModel, List<FieldModel> manyToManyDependencies)
    {
        var sb = new StringBuilder();
        sb.AppendLine("    // Many-to-many relationships");
        foreach (var i in manyToManyDependencies)
        {
            // i.TableModel is the many-to-many table, so we need to get the actual table model from the ManyToManyModel
            var manyToMany = tableModel.DatabaseModel.ManyToManyModels.First(q => q.TableModel == i.TableModel);
            
            var otherField = manyToMany.Fields.First(q => q != i);
            var distantTableModel = otherField.ReferencedTableModel;
            sb.AppendLine($"        {i.TableModel.TypeName}_{i.CapitalizedName}Ids.ItemAdded -= {i.TableModel.TypeName}_{i.CapitalizedName}ItemAdded;");
            sb.AppendLine($"        {i.TableModel.TypeName}_{i.CapitalizedName}Ids.ItemRemoved -= {i.TableModel.TypeName}_{i.CapitalizedName}ItemRemoved;");
        }
        return sb.ToString();
    }

    private static string GenerateDependencyDisposers(TableModel tableModel)
    {
        var sb = new StringBuilder();
        foreach (var i in tableModel.Dependencies)
        {
            if (!i.TableModel.GenerateViewModel) continue;
            if (string.IsNullOrEmpty(i.CollectionName)) continue;
            if (i.TableModel.IsManyToMany) continue;
            var idCollection = $"{i.CollectionName}Ids";
            sb.AppendLine($@"        {idCollection}.ItemAdded -= {i.CollectionName}ItemAdded;
        {idCollection}.ItemRemoved -= {i.CollectionName}ItemRemoved;");
        }

        return sb.ToString();
    }

    private static string GenerateDependencyProperties(TableModel tableModel)
    {
        var sb = new StringBuilder();
        foreach (var i in tableModel.Dependencies)
        {
            if (!i.TableModel.GenerateViewModel) continue;
            if (string.IsNullOrEmpty(i.CollectionName)) continue;
            if (i.TableModel.IsManyToMany) continue;
            sb.AppendLine($"    public ObservableList<{i.TableModel.TypeName}ViewModel> {i.CollectionName} {{ get; set; }} = new ();");
            sb.AppendLine($"    private ObservableList<int> {i.CollectionName}Ids;");
            sb.AppendLine($"    private Action<int, int> {i.CollectionName}ItemAdded;");
            sb.AppendLine($"    private Action<int, int> {i.CollectionName}ItemRemoved;");
        }
        return sb.ToString();
    }
    
    private static string GenerateManyToManyProperties(TableModel tableModel, List<FieldModel> manyToManyDependencies)
    {
        var sb = new StringBuilder();
        sb.AppendLine("    // Many-to-many relationships");
        var collections = new HashSet<string>();
        foreach (var i in manyToManyDependencies)
        {
            // i.TableModel is the many-to-many table, so we need to get the actual table model from the ManyToManyModel
            var manyToMany = tableModel.DatabaseModel.ManyToManyModels.First(q => q.TableModel == i.TableModel);
            var addCollection = true;
            if(manyToMany.IsSymmetricJunction)
            {
                // If this is a symmetric junction, we only need to generate one collection and one index map
                if(collections.Contains(i.CollectionName)) 
                    addCollection = false;
                collections.Add(i.CollectionName);
            }
            sb.AppendLine($"    // {manyToMany.TableModel.TypeName} is a many-to-many relationship table");
            sb.AppendLine($"    // Field1: {manyToMany.Fields[0].Name} - Field2: {manyToMany.Fields[1].Name}");
            var otherField = manyToMany.Fields.First(q => q != i);
            sb.AppendLine($"    // {otherField.ReferencedTableModel.TypeName} is the other table in the many-to-many relationship");
            var distantTableModel = otherField.ReferencedTableModel;
            if(addCollection)
            {
                sb.AppendLine($"    public ObservableList<{distantTableModel.TypeName}ViewModel> {i.CollectionName} {{ get; set; }} = new ();");
                sb.AppendLine($"    private IdMap {i.CollectionName}Index = new();");
            }
            sb.AppendLine($"    private ObservableList<int> {i.TableModel.TypeName}_{i.CapitalizedName}Ids;");
            sb.AppendLine($"    private Action<int, int> {i.TableModel.TypeName}_{i.CapitalizedName}ItemAdded;");
            sb.AppendLine($"    private Action<int, int> {i.TableModel.TypeName}_{i.CapitalizedName}ItemRemoved;");
        }
        return sb.ToString();
    }


    private static string GenerateValueChanged(TableModel tableModel)
    {
        var sb = new StringBuilder();
        foreach (var field in tableModel.Fields)
        {
            sb.AppendLine($"        {field.CapitalizedName}.Value = newRow.data.{field.Name};");
        }

        return sb.ToString();
    }

    private static string GenerateProperties(TableModel tableModel)
    {
        var sb = new StringBuilder();
        foreach (var field in tableModel.Fields)
        {
            sb.AppendLine($"    public readonly ObservableProperty<{field.QualifiedTypeName}> {field.CapitalizedName} = new();");
            if (field.IsReference && field.ReferencedTableModel.GenerateViewModel && !string.IsNullOrEmpty(field.PropertyName))
            {
                sb.AppendLine($"    public {field.ReferencedTableModel.TypeName}ViewModel {field.PropertyName} => {field.CapitalizedName}.Value == default ? null : manager.{field.ReferencedTableModel.TypeName}ViewModels.Get({field.CapitalizedName}.Value);");
            }
        }

        return sb.ToString();
    }
}