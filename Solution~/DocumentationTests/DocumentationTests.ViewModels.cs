namespace DocumentationTests.ViewModels;
using IntegrityTables;


[GenerateDatabase]
public partial class Database
{
}

// Adding a [GenerateViewModel] attribute to the table will generate a ViewModel and supporting classes for this table.
// This allows you to easily access the data in the table, and also provides a way to get notified when the data changes.
// It is most often used for UI applications, but can also be used in other scenarios where you want to access the data in a more convenient way.
[GenerateTable(typeof(Database), GenerateViewModel = true), Serializable]
public partial struct User
{
    [Unique]
    public string email;
}

[GenerateTable(typeof(Database), GenerateViewModel = true), Serializable]
public partial struct Message
{
    [Reference(typeof(User), CollectionName = "SentMessages", PropertyName = "Sender", NotNull = true)]
    public int senderId;
    [Reference(typeof(User), CollectionName = "ReceivedMessages", NotNull = true)]
    public int recipientId;

    public string subject;
    public string text;
}

public class TestDocumentation
{
    [Test]
    public void TestMethod()
    {
        var db = new Database();
        // The viewModelManager is used to manage the ViewModels for the database.
        // It will automatically create and dispose of ViewModels as needed.
        var viewModelManager = new DatabaseViewModelManager(db);

        // add a new user to the database
        var user = db.UserTable.Add(new User() {email = "simon@simon.com"});

        // This creates a ViewModel for the user just created.
        var viewModel = viewModelManager.UserViewModels.Get(user.id);
        
        // the Email property is automatically generated by the ViewModel source generator.
        // It will return the value of the email field in the User table when cast as string, or when the .Value property is used.
        Assert.That((string)viewModel.Email, Is.EqualTo("simon@simon.com"));
        Assert.That(viewModel.Email.Value, Is.EqualTo("simon@simon.com"));

        // save the current email value, so we can check if it changes later.
        var email = viewModel.Email.Value;
        
        // setup a lambda to observe changes to the ViewModel Email property.
        viewModel.Email.OnChanged += (oldEmail, newEmail) =>
        {
            // This will be called whenever the email field in the User table is changed.
            email = newEmail;
        };
        
        // Update the email field in the User table.
        user.data.email = "boris@simon.com";
        db.UserTable.Update(ref user);
        
        // The ViewModel property observer will automatically update the email variable to reflect the change.
        Assert.That(email, Is.EqualTo("boris@simon.com"));
        
        // we also generated a ViewModel for the Message table, so we can get them directly from the user ViewModel in an ObservableList.
        var messages = viewModel.SentMessages;
        
        Assert.That(messages.Count, Is.EqualTo(0));
        
        //send a message
        db.MessageTable.Add(new Message() {recipientId = user.id, senderId = user.id, text = "Hello to myself."});
        
        // The message view model is now available in the messages list.
        Assert.That(messages.Count, Is.EqualTo(1));

        var messageViewModel = messages[0];
        Assert.That(messageViewModel.Text.Value, Is.EqualTo("Hello to myself."));

    }
}

